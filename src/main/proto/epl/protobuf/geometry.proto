/*
Copyright 2017-2018 Echo Park Labs

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

For additional information, contact:

email: info@echoparklabs.io
*/

syntax = "proto2";

option java_multiple_files = true;
option java_package = "com.epl.protobuf.geometry";
option java_outer_classname = "GeometryProto";
option objc_class_prefix = "RTG";
option go_package = "github.com/geo-grpc/api/golang/epl/protobuf";

package epl.protobuf;

/*
  type of geometry operators
*/
enum GeometryEncodingType {
    unknown = 0;
    wkb = 1; // well-known binary
    wkt = 2; // well-known text
    geojson = 3; // geojson
    esrishape = 4; // esri shape binary
}

/*
  type of geometry operators
*/
enum ServiceOperatorType {
    Project = 0; // project geometry from one spatial reference to another

    ExportToJson = 1; // deprecated
    ImportFromJson = 2; // deprecated
    ImportMapGeometryFromJson = 3; // deprecated

    ExportToESRIShape = 4; // export geometry to esrishape binary data
    ImportFromESRIShape = 5; // import from esrishape binary data

    Union = 6; // union two or more geometries
    Difference = 7; // difference of two or more geometries

    Proximity2D = 8; // not yet exposed

    Relate = 9; // not yet exposed 9 dim
    Equals = 10; // relational operator
    Disjoint = 11; // relational operator
    Intersects = 12; // relational operator
    Within = 13; // relational operator
    Contains = 14; // relational operator
    Crosses = 15; // relational operator
    Touches = 16; // relational operator
    Overlaps = 17; // relational operator

    Buffer = 18; // create polygon that is a buffer of the inputs
    Distance = 19; // not yet exposed
    Intersection = 20; // intersection of two or more geometries
    Clip = 21; // clip a geometry or geometries by a horizon
    Cut = 22; // cut geometry
    DensifyByLength = 23;
    // DensifyByAngle = 24;
    // LabelPoint = 25;

    GeodesicBuffer = 26;
    GeodeticDensifyByLength = 27;
    // ShapePreservingDensify = 28;
    GeodeticLength = 29;
    // GeodeticArea = 30;

    Simplify = 31;
    SimplifyOGC = 32;
    Offset = 33;
    Generalize = 34;
    GeneralizeByArea = 35;

    ExportToWkb = 36;
    ImportFromWkb = 37;
    ExportToWkt = 38;
    ImportFromWkt = 39;
    ImportFromGeoJson = 40;
    ExportToGeoJson = 41;
    SymmetricDifference = 42;
    ConvexHull = 43;
    Boundary = 44;
    RandomPoints = 45;
    EnclosingCircle = 46;
}

enum OffsetJoinType {
    Round = 0;
    Bevel = 1;
    Miter = 2;
    Square =3;
}

message GeometryData {
    optional int64 geometry_id = 1;
    optional string feature_id = 9;

    optional GeometryEncodingType geometry_encoding_type = 2;
    // oneof block
    optional string wkt = 3;
    optional string geojson = 4;
    optional bytes  wkb = 5;
    optional bytes  esri_shape = 6;
    // oneof block
    optional SpatialReferenceData  spatial_reference = 7;
}

message GeometryBagData {
    // oneof block start
    repeated int64 geometry_ids = 1;
    repeated string feature_ids = 9;
    // oneof block end

    // type can be 'wkt', 'wkb', 'geojson', or 'esri'
    optional GeometryEncodingType geometry_encoding_type = 2;

    repeated string wkt = 3;
    repeated string geojson = 4;
    repeated bytes wkb = 5;
    repeated bytes esri_shape = 6;

    optional SpatialReferenceData  spatial_reference = 7;

    repeated string esri_json = 8;
}

message SpatialReferenceData {
    optional string proj4 = 4;
    // String that is a wkt, wkid, esri_wkt, or a proj4 string
    optional string esri_wkt = 5;

    // type is either 'wkid', 'esri_wkt'
    optional int32  wkid = 6;
}

message OperatorResult {
    optional GeometryBagData  geometry_bag = 1;

    optional bool  spatial_relationship = 2;

    optional double  distance = 3;

    map<int64, bool> relate_map = 4;
}

enum FileType {
    Shapefile = 0;
}

message FileChunk {
    optional OperatorRequest nested_request = 1;
    optional GeometryEncodingType  results_encoding_type = 2;

    optional SpatialReferenceData  input_spatial_reference = 3;
    optional SpatialReferenceData  result_spatial_reference = 5;

    optional bytes  data = 6;
    optional int64 size = 7;
    optional int64 offset = 8;
    optional string file_name = 9;

    optional bool  is_last_chunk = 10;
}

message BufferParams {
    repeated double distances = 1;
    repeated double max_deviations = 2;
    optional bool  union_result = 3;
    optional int32  max_vertices_in_full_circle = 4;
}

message GeodeticBufferParams {
    repeated double distances = 1;
    repeated double max_deviations = 2;
    optional bool  union_result = 3;
    optional int32  max_vertices_in_full_circle = 4;
}

message ConvexParams {
    optional bool  merge = 1;
}

message RelateParams {
    optional string de_9im = 1;
}

message RandomPointsParams {
    repeated double points_per_square_km = 1;
    optional int64 seed = 2;
}

message GeneralizeParams {
    optional double  max_deviation = 1;
    optional bool  remove_degenerates = 2;
}

message GeneralizeByAreaParams {
    optional double  percent_reduction = 1;
    optional bool  remove_degenerates = 2;
    optional int32  max_point_count = 3;
}

message IntersectionParams {
    optional int32  dimension_mask = 1;
}

message OffsetParams {
    optional double  distance = 1;
    optional OffsetJoinType join_type = 2;
    optional double  bevel_ratio = 3;
    optional double  flatten_error = 4;
}

message CutParams {
    optional bool  consider_touch = 1;
}

message ClipParams {
    optional EnvelopeData envelope = 1;
}

message DensifyParams {
    optional double  max_length = 1;
}

message SimplifyParams {
    optional bool  force = 1;
}

message OperatorRequest {
    //    oneof primary_geoms {
    optional GeometryBagData  geometry_bag = 1;
    optional OperatorRequest geometry_request = 2;
    optional GeometryBagData  left_geometry_bag = 3;
    optional OperatorRequest left_geometry_request = 4;
    //    }

    //    oneof secondary_geoms {
    optional GeometryBagData  right_geometry_bag = 5;
    optional OperatorRequest right_geometry_request = 6;
    //    }

    optional ServiceOperatorType operator_type = 7;

    optional GeometryEncodingType  results_encoding_type = 8;

    optional SpatialReferenceData  operation_spatial_reference = 9;

    optional SpatialReferenceData  result_spatial_reference = 10;

    //    oneof params {
    optional BufferParams buffer_params = 11;
    optional ConvexParams convex_params = 12;
    optional RelateParams relate_params = 13;
    optional RandomPointsParams random_points_params = 14;
    optional GeneralizeParams generalize_params = 15;
    optional IntersectionParams intersection_params = 16;
    optional OffsetParams offset_params = 17;
    optional CutParams cut_params = 18;
    optional ClipParams clip_params = 19;
    optional DensifyParams densify_params = 20;
    optional SimplifyParams simplify_params = 21;
    optional GeneralizeByAreaParams generalize_by_area_params = 22;
    //    }

    optional GeometryData geometry = 23;
    optional GeometryData left_geometry = 24;
    optional GeometryData right_geometry = 25;
}


message EnvelopeData {
    optional double  xmin = 1;
    optional double  ymin = 2;
    optional double  xmax = 3;
    optional double  ymax = 4;
    optional SpatialReferenceData  spatial_reference = 5;
}

